<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/models/llm_requests.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/models/llm_requests.py" />
              <option name="originalContent" value="import uuid&#10;from typing import List, Optional, Any, Dict&#10;from pydantic import BaseModel, Field, EmailStr&#10;&#10;&#10;class Rights(BaseModel):&#10;    owner: str = &quot;184431757886694&quot;&#10;&#10;class Props(BaseModel):&#10;    active: str = &quot;true&quot;&#10;    name: str&#10;    description: Optional[str] = &quot;&quot;&#10;class BaseLLMRequest(BaseModel):&#10;    id: Optional[str] = None&#10;    rights: Rights&#10;    priority: str = &quot;Normal&quot;&#10;    props: Props&#10;    skip: str = &quot;false&quot;&#10;    folder: str = &quot;3023602439587835&quot;&#10;&#10;    def ensure_id(self):&#10;        if not self.id:&#10;            self.id = str(uuid.uuid4())&#10;&#10;    def template_key(self) -&gt; str:&#10;        raise NotImplementedError&#10;&#10;    def to_field_values(self) -&gt; Dict[str, Any]:&#10;        raise NotImplementedError&#10;&#10;&#10;class SendEmailVariables(BaseModel):&#10;    query: str&#10;    to: EmailStr&#10;    cc: Optional[str] = &quot;&quot;&#10;    subject: str&#10;    text: str&#10;    attachment: bool = True&#10;    connection: str&#10;&#10;class SendEmailLLMRequest(BaseLLMRequest):&#10;    template: str = &quot;110673709194435&quot;&#10;    variables: List[SendEmailVariables]&#10;&#10;    def template_key(self) -&gt; str:&#10;        return &quot;SENDEMAIL&quot;&#10;&#10;    def to_field_values(self) -&gt; Dict[str, Any]:&#10;        return {&#10;            &quot;template&quot;: self.template,&#10;            &quot;connection&quot;: self.variables.connection,&#10;            &quot;sql_query&quot;: self.variables.sql_query,&#10;            &quot;to&quot;: self.variables.to,&#10;            &quot;cc&quot;: self.variables.cc or &quot;&quot;,&#10;            &quot;subject&quot;: self.variables.subject,&#10;            &quot;text&quot;: self.variables.text,&#10;            &quot;attachment&quot;: &quot;true&quot; if self.variables.attachment else &quot;false&quot;,&#10;        }&#10;&#10;&#10;class SelectedColumn(BaseModel):&#10;    columnName: str&#10;&#10;class ReadSqlVariables(BaseModel):&#10;    table_name: str&#10;    query: str&#10;    write_count: bool = False&#10;    write_count_connection: str = &quot;&quot;&#10;    execute_query: bool = True&#10;    result_schema: str&#10;    only_dataset_columns: bool = True&#10;    write_count_table: str = &quot;&quot;&#10;    drop_before_create: bool = False&#10;    # columns: List[SelectedColumn] = Field(default_factory=list)&#10;&#10;&#10;class ReadSqlLLMRequest(BaseLLMRequest):&#10;    template: str = &quot;2223045341865624&quot;&#10;    variables: List[ReadSqlVariables]&#10;&#10;    def template_key(self) -&gt; str:&#10;        return &quot;READSQL&quot;&#10;&#10;    def to_field_values(self) -&gt; Dict[str, Any]:&#10;        return {&#10;            &quot;customer_id&quot;: self.customer_id,&#10;            &quot;sql&quot;: self.sql,&#10;            &quot;columns_json&quot;: [c.model_dump() for c in self.columns],&#10;            &quot;paginate&quot;: &quot;true&quot; if self.paginate else &quot;false&quot;,&#10;            &quot;limit&quot;: None if self.limit is None else self.limit,&#10;            &quot;output_name&quot;: self.output_name,&#10;            &quot;output_path&quot;: self.output_path,&#10;            &quot;overwrite&quot;: &quot;true&quot; if self.overwrite else &quot;false&quot;,&#10;            &quot;opt_a&quot;: self.opt_a,&#10;            &quot;opt_b&quot;: self.opt_b,&#10;            &quot;return_json&quot;: &quot;true&quot; if self.return_json else &quot;false&quot;,&#10;            &quot;return_csv&quot;: &quot;true&quot; if self.return_csv else &quot;false&quot;,&#10;        }&#10;&#10;&#10;class ColumnSchema(BaseModel):&#10;    columnName: str&#10;    columnType: Optional[str] = None&#10;    columnLength: Optional[int] = 2000&#10;    alias: str = &quot;&quot;&#10;&#10;class WriteDataVariables(BaseModel):&#10;    only_dataset_columns: bool = True&#10;    write_count_schema: bool = False&#10;    #add_columns: List[ColumnSchema] = Field(default_factory=list)&#10;    #columns: List[ColumnSchema] = Field(default_factory=list)&#10;    connection: str&#10;    schemas: str&#10;    table: str&#10;    write_count_table: str = &quot;&quot;&#10;&#10;&#10;class WriteDataLLMRequest(BaseLLMRequest):&#10;    template: str = &quot;28405918884279&quot;&#10;    variables: List[WriteDataVariables]&#10;&#10;    def template_key(self) -&gt; str:&#10;        return &quot;WRITEDATA&quot;&#10;&#10;    def to_field_values(self) -&gt; Dict[str, Any]:&#10;        # Returns a list of dicts for each variable in variables&#10;        return {&#10;                &quot;template&quot;: self.template,&#10;                &quot;only_dataset_columns&quot;: self.variables.only_dataset_columns,&#10;                &quot;write_count_schema&quot;: self.variables.write_count_schema,&#10;                &quot;connection&quot;: self.variables.connection,&#10;                &quot;schemas&quot;: self.variables.schemas,&#10;                &quot;table&quot;: self.variables.table,&#10;                &quot;write_count_table&quot;: self.variables.write_count_table,&#10;            }&#10;  &#10;        &#10;" />
              <option name="updatedContent" value="import uuid&#10;from typing import List, Optional, Any, Dict&#10;from pydantic import BaseModel, Field, EmailStr&#10;&#10;&#10;class Rights(BaseModel):&#10;    owner: str = &quot;184431757886694&quot;&#10;&#10;class Props(BaseModel):&#10;    active: str = &quot;true&quot;&#10;    name: str&#10;    description: Optional[str] = &quot;&quot;&#10;class BaseLLMRequest(BaseModel):&#10;    id: Optional[str] = None&#10;    rights: Rights&#10;    priority: str = &quot;Normal&quot;&#10;    props: Props&#10;    skip: str = &quot;false&quot;&#10;    folder: str = &quot;3023602439587835&quot;&#10;&#10;    def ensure_id(self):&#10;        if not self.id:&#10;            self.id = str(uuid.uuid4())&#10;&#10;    def template_key(self) -&gt; str:&#10;        raise NotImplementedError&#10;&#10;    def to_field_values(self) -&gt; Dict[str, Any]:&#10;        raise NotImplementedError&#10;&#10;&#10;class SendEmailVariables(BaseModel):&#10;    query: str&#10;    to: EmailStr&#10;    cc: Optional[str] = &quot;&quot;&#10;    subject: str&#10;    text: str&#10;    attachment: bool = True&#10;    connection: str&#10;&#10;class SendEmailLLMRequest(BaseLLMRequest):&#10;    template: str = &quot;110673709194435&quot;&#10;    variables: List[SendEmailVariables]&#10;&#10;    def template_key(self) -&gt; str:&#10;        return &quot;SENDEMAIL&quot;&#10;&#10;    def to_field_values(self) -&gt; Dict[str, Any]:&#10;        return {&#10;            &quot;template&quot;: self.template,&#10;            &quot;connection&quot;: self.variables.connection,&#10;            &quot;sql_query&quot;: self.variables.sql_query,&#10;            &quot;to&quot;: self.variables.to,&#10;            &quot;cc&quot;: self.variables.cc or &quot;&quot;,&#10;            &quot;subject&quot;: self.variables.subject,&#10;            &quot;text&quot;: self.variables.text,&#10;            &quot;attachment&quot;: &quot;true&quot; if self.variables.attachment else &quot;false&quot;,&#10;        }&#10;&#10;&#10;class SelectedColumn(BaseModel):&#10;    columnName: str&#10;&#10;class ReadSqlVariables(BaseModel):&#10;    table_name: str&#10;    query: str&#10;    write_count: bool = False&#10;    write_count_connection: str = &quot;&quot;&#10;    execute_query: bool = True&#10;    result_schema: str&#10;    only_dataset_columns: bool = True&#10;    write_count_table: str = &quot;&quot;&#10;    drop_before_create: bool = False&#10;    # columns: List[SelectedColumn] = Field(default_factory=list)&#10;&#10;&#10;class ReadSqlLLMRequest(BaseLLMRequest):&#10;    template: str = &quot;2223045341865624&quot;&#10;    variables: List[ReadSqlVariables]&#10;&#10;    def template_key(self) -&gt; str:&#10;        return &quot;READSQL&quot;&#10;&#10;    def to_field_values(self) -&gt; List[Dict[str, Any]]:&#10;        # Returns a list of dicts for each variable in variables&#10;        return [&#10;            {&#10;                &quot;table_name&quot;: v.table_name,&#10;                &quot;query&quot;: v.query,&#10;                &quot;write_count&quot;: v.write_count,&#10;                &quot;write_count_connection&quot;: v.write_count_connection,&#10;                &quot;execute_query&quot;: v.execute_query,&#10;                &quot;result_schema&quot;: v.result_schema,&#10;                &quot;only_dataset_columns&quot;: v.only_dataset_columns,&#10;                &quot;write_count_table&quot;: v.write_count_table,&#10;                &quot;drop_before_create&quot;: v.drop_before_create,&#10;            }&#10;            for v in self.variables&#10;        ]&#10;&#10;&#10;class ColumnSchema(BaseModel):&#10;    columnName: str&#10;    columnType: Optional[str] = None&#10;    columnLength: Optional[int] = 2000&#10;    alias: str = &quot;&quot;&#10;&#10;class WriteDataVariables(BaseModel):&#10;    only_dataset_columns: bool = True&#10;    write_count_schema: bool = False&#10;    #add_columns: List[ColumnSchema] = Field(default_factory=list)&#10;    #columns: List[ColumnSchema] = Field(default_factory=list)&#10;    connection: str&#10;    schemas: str&#10;    table: str&#10;    write_count_table: str = &quot;&quot;&#10;&#10;&#10;class WriteDataLLMRequest(BaseLLMRequest):&#10;    template: str = &quot;28405918884279&quot;&#10;    variables: List[WriteDataVariables]&#10;&#10;    def template_key(self) -&gt; str:&#10;        return &quot;WRITEDATA&quot;&#10;&#10;    def to_field_values(self) -&gt; Dict[str, Any]:&#10;        # Returns a list of dicts for each variable in variables&#10;        return {&#10;                &quot;template&quot;: self.template,&#10;                &quot;only_dataset_columns&quot;: self.variables.only_dataset_columns,&#10;                &quot;write_count_schema&quot;: self.variables.write_count_schema,&#10;                &quot;connection&quot;: self.variables.connection,&#10;                &quot;schemas&quot;: self.variables.schemas,&#10;                &quot;table&quot;: self.variables.table,&#10;                &quot;write_count_table&quot;: self.variables.write_count_table,&#10;            }" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>